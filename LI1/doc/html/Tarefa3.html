<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Tarefa3</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Daniel Furtado &lt;a97327@alunos.uminho.pt&gt;;<br />Gabriela Cunha &lt;a97393@alunos.uminho.pt&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Tarefa3</p></div><div id="description"><p class="caption">Description</p><div class="doc"><h1>Introdu&#231;&#227;o</h1><p>Nesta tarefa compactamos o labirinto, tornando-o numa lista de instru&#231;&#245;es de modo a facilitar a leitura.</p><h1>Objetivos e estrat&#233;gias </h1><p>No in&#237;cio da tarefa pensamos em primeiro elaborar o que est&#225; dentro da <a href="Instruct.html">Instruct</a>, ou seja, colocar tudo em pares de inteiros e pe&#231;as e s&#243; depois focar na parte do <a href="Repeat.html">Repeat</a>, que acontece quando h&#225; corredores iguais.</p><p>Em rela&#231;&#227;o ao que est&#225; dentro da instru&#231;&#227;o <strong><em>Instruct</em></strong> :</p><ul><li>Agrupamos as pe&#231;as iguais e seguidas de modo a tornar o labirinto em pares em que a primeira componente &#233; o n&#186; de pe&#231;as seguidas iguais e a segunda a respetiva pe&#231;a;</li></ul><p>Para a realiza&#231;&#227;o de fun&#231;&#227;o utilizamos 2 fun&#231;&#245;es auxiliares:</p><ol><li>Uma para transformar o corredor em formato (1,Pe&#231;a);</li><li>Outra que verifica se a pe&#231;a a seguir &#233; igual &#224; anterior e se isto acontecer soma as primeiras componentes dos pares e mant&#233;m a segunda;</li></ol><p>J&#225; em rela&#231;&#227;o &#224; instru&#231;&#227;o <strong><em>Repeat</em></strong> :</p><p>Pretendemos comparar os corredores dos labirintos um a um para saber se dever&#237;amos usar o <strong><em>Repeat</em></strong> caso j&#225; existisse um igual e ainda saber o &#237;ndice da primeira vez que o corredor aparecia.</p><p>Assim sendo, utilizamos uma fun&#231;&#227;o que recebia 2 mazes iguais e comparava cada corredor do 1&#186; Maze com todos do segundo e guardava o &#237;ndice no 2&#186; Maze da primeira vez que aparecesse um corredor igual ao corredor dado;</p><p>Para esta fun&#231;&#227;o recorremos a uma fun&#231;&#227;o auxiliar que dado um corredor devolvia a posi&#231;&#227;o do corredor no Maze.</p><p>Com as fun&#231;&#245;es terminandas, pudemos ent&#227;o juntar as fun&#231;&#245;es e aplicar as instru&#231;&#245;es na fun&#231;&#227;o <strong><code><a href="Tarefa3.html#v:instructMaze" title="Tarefa3">instructMaze</a></code></strong>.</p><p>Na fun&#231;&#227;o principal utilizamos a fun&#231;&#227;o <strong><code><a href="Tarefa3.html#v:instructMaze" title="Tarefa3">instructMaze</a></code></strong> para aplicar as instru&#231;&#245;es e as fun&#231;&#245;es <strong><code><a href="Tarefa3.html#v:mazeToTuple" title="Tarefa3">mazeToTuple</a></code></strong> e <strong><code><a href="Tarefa3.html#v:corridorIndex" title="Tarefa3">corridorIndex</a></code></strong> para transformar o Maze dado nos tuplos pretendidos inicialmente e obter os &#237;ndices dos corredores.</p><h1>Conclus&#227;o</h1><p>Apesar desta tarefa ser r&#225;pida e mais simples em rela&#231;&#227;o &#224;s 2 anteriores, foi bastante &#250;til para simplificar os nossos testes e exemplos e tornar o nosso c&#243;digo mais &quot;limpo&quot;.</p><p>Conclu&#237;mos tamb&#233;m que nos ajudou a perceber o qu&#227;o facilita &#224;s vezes recorrer a fun&#231;&#245;es auxiliares e acumuladores porque foi algo bastante usado ao longo da tarefa e que ajudou imenso.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:corridorToTuple">corridorToTuple</a> :: <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)]</li><li class="src short"><a href="#v:mazeToTuple">mazeToTuple</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; [[(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)]]</li><li class="src short"><a href="#v:gatherPieces">gatherPieces</a> :: [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)] -&gt; [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)]</li><li class="src short"><a href="#v:corridorIndex">corridorIndex</a> :: Int -&gt; <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; Int</li><li class="src short"><a href="#v:mazeIndex">mazeIndex</a> :: Int -&gt; <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; [Int]</li><li class="src short"><a href="#v:instructMaze">instructMaze</a> :: Int -&gt; [Int] -&gt; [[(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)]] -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></li><li class="src short"><a href="#v:compactMaze">compactMaze</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:corridorToTuple" class="def">corridorToTuple</a> :: <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)] <a href="#v:corridorToTuple" class="selflink">#</a></p><div class="doc"><p>Converte um corredor para uma lista de tuplos (Integer,Piece).</p><p><strong>Exemplo :</strong></p><pre>corridorToTuple [Wall,Empty,Wall,Wall,Food Big] = [(1,Wall),(1,Empty),(1,Wall),(1,Wall),(1,Food Big)]
</pre></div></div><div class="top"><p class="src"><a id="v:mazeToTuple" class="def">mazeToTuple</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; [[(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)]] <a href="#v:mazeToTuple" class="selflink">#</a></p><div class="doc"><p>Converte um labirinto numa lista de corredor no tipo (Integer,Piece).</p><p>Utiliza as fun&#231;&#245;es <strong><code><a href="Tarefa3.html#v:corridorToTuple" title="Tarefa3">corridorToTuple</a></code></strong> and <strong><code><a href="Tarefa3.html#v:gatherPieces" title="Tarefa3">gatherPieces</a></code></strong>. </p><p>Devolve j&#225; um labirinto onde os corredores s&#227;o listas de tuplos e as pe&#231;as seguidas est&#227;o juntas.</p></div></div><div class="top"><p class="src"><a id="v:gatherPieces" class="def">gatherPieces</a> :: [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)] -&gt; [(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)] <a href="#v:gatherPieces" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <strong>gatherPieces</strong> junta tuplos seguidos se a pe&#231;a for a mesma.</p><p><strong>Exemplo :</strong></p><pre>gatherPieces [(1,Wall),(1,Empty),(1,Wall),(1,Wall),(1,Food Big)] = [(1,Wall),(1,Empty),(2,Wall),(1,Food Big)].
</pre></div></div><div class="top"><p class="src"><a id="v:corridorIndex" class="def">corridorIndex</a> :: Int -&gt; <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; Int <a href="#v:corridorIndex" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <strong>corridorIndex</strong> recebe um corredor e um labirinto e devolve a posi&#231;&#227;o do corredor no labirinto.</p><p>Usamos um acumulador para ajudar a contar a posi&#231;&#227;o. O acumulador come&#231;a sempre em <strong>0</strong>. </p></div></div><div class="top"><p class="src"><a id="v:mazeIndex" class="def">mazeIndex</a> :: Int -&gt; <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; [Int] <a href="#v:mazeIndex" class="selflink">#</a></p><div class="doc"><p>A fun&#231;&#227;o <strong>mazeIndex</strong> recebe <strong>2</strong> labirintos e compara cada corredor do primeiro Maze com todos do segundo.</p><ul><li>Quando o corredor do 1&#186; Maze &#233; igual ao do 2&#186;, a fun&#231;&#227;o guarda o &#237;ndice do corredor no 2&#186; Maze e aplica a fun&#231;&#227;o ao pr&#243;ximo corredor do 1&#186; Maze. </li><li>Como comparamos labirintos iguais, a fun&#231;&#227;o verifica qual &#233; o &#237;ndice da 1&#170; vez que cada corredor do 1&#186; maze aparece no 2&#186; e guarda os &#237;ndices numa lista.</li><li>Na fun&#231;&#227;o voltamos a recorrer a um acumulador.</li></ul><p><strong>Exemplo :</strong></p><pre>mazeIndex 0 [[Wall,Wall],[Wall,Food Big],[Wall,Food Big],[Wall,Wall],[Empty,Empty]] [[Wall,Wall],[Wall,Food Big],[Wall,Food Big],[Wall,Wall],[Empty,Empty]] = [0,1,1,0,4]
</pre></div></div><div class="top"><p class="src"><a id="v:instructMaze" class="def">instructMaze</a> :: Int -&gt; [Int] -&gt; [[(Int, <a href="Types.html#t:Piece" title="Types">Piece</a>)]] -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a> <a href="#v:instructMaze" class="selflink">#</a></p><div class="doc"><p>Recebe uma lista de n&#250;meros e um labirinto em tuplos e retorna a lista de corredores com <strong>Instruct</strong> e <strong>Repeat</strong>.</p><p>Voltamos a usar um acumulador.</p><p><strong>Exemplo :</strong></p><pre>instructMaze 0 [0,1,1,0,4] [[(2,Wall)],[(1,Wall),(1,Food Big)],[(1,Wall),(1,Food Big)],[(2,Wall)],[(2,Empty)]] = [Instruct [(2,<a id=")],Instruct [(1,"></a>),(1,o)],Repeat 1,Repeat 0,Instruct [(2, )]]
</pre></div></div><div class="top"><p class="src"><a id="v:compactMaze" class="def">compactMaze</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a> <a href="#v:compactMaze" class="selflink">#</a></p><div class="doc"><p>Fun&#231;&#227;o principal que compacta o maze.</p><p>Recebe um Maze e retorna o Maze com as pe&#231;as agrupadas em corredores com <strong>Instruct</strong> e <strong>Repeat</strong>.</p><p><strong>Exemplo :</strong></p><pre>compactMaze [[Wall,Wall],[Wall,Food Big],[Wall,Food Big],[Wall,Wall],[Empty,Empty]] = [Instruct [(2,<a id=")],Instruct [(1,"></a>),(1,o)],Repeat 1,Repeat 0,Instruct [(2, )]]
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>